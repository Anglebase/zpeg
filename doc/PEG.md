# Parsing Expression Grammar (PEG) File Syntax Overview

A Parsing Expression Grammar file is a formalism for describing the context-free grammar of programming languages, which can be used to generate AST parsers to simplify compiler front-end development.

## Syntax

Note: *The syntax described in this document applies only to zpeg*

### Comments

PEG supports single-line comments:

```peg
# This is a single-line comment

# -------------------
# Multi-line comments use multiple single-line comments
# -------------------
```

During parsing, all whitespace and comments are discarded. They do not participate in semantic analysis.

### Identifiers

Identifiers in PEG must begin with a letter, underscore (`_`), or colon (`:`), followed by any number of letters, digits, underscores (`_`), and colons (`:`).
Additionally, PEG supports the same extended identifier syntax as Zig: `@"..."`

```peg
A       # ok
::G     # ok
@"@#%"  # ok

2ffd    # no
```

### Basic Structure

The basic structure of a PEG file is as follows:

```peg
PEG <<ident>> (<<Expr>>)
    <<rules>>
END;
```

Here, `<<ident>>` should be an identifier that declares the entire PEG file, `<<Expr>>` is the root expression of the PEG, and `<<rules>>` are the PEG rules.

### Rules

A rule has the following structure:

```peg
[[<<attr>>:]] <<ident>> <- <<Expr>> ;
```

At the beginning of a rule, there is an optional attribute identifier that indicates how to interpret the node when generating the AST. If it is empty, it will be stored as an AST node, and the nodes generated by its expression will become its children; if it is `leaf`, it means this rule produces a leaf node, and the nodes generated by its expression will be discarded; if it is `void`, it means this is just a semantic node and will not be stored in the AST.

### Expressions

An expression can be any of the following or their combinations:

- **And predicate `&`**: `&e` indicates that if from the current position forward, the input can be interpreted as the expression `e`, then this rule succeeds; otherwise it fails. It does not advance the current position.
- **Not predicate `!`**: `!e` indicates that if from the current position forward, the input cannot be interpreted as the expression `e`, then this rule succeeds; otherwise it fails. It does not advance the current position.
- **Sequence**: For `e1 e2 ...`, it attempts to parse starting from `e1` sequentially. If all operations succeed, the entire rule succeeds; if any one fails, the entire rule fails.
- **Ordered choice**: For `e1 | e2 | ...`, it attempts to parse starting from `e1` until the first successfully parsed rule is encountered, at which point the entire rule succeeds; if all fail, the entire rule fails.
- **Zero or more `*`**: `e*` indicates that for the rule `e`, it will attempt to match `e` as many times as possible until matching `e` fails. This operation cannot fail.
- **One or more `+`**: `e+` indicates that for the rule `e`, it must succeed at least once, after which it will attempt to match `e` as many times as possible until matching `e` fails. Equivalent to `e e*`.
- **Optional `?`**: `e?` indicates that for the rule `e`, it should be matched zero or one time. This operation cannot fail.
- **String literal**: String literals are enclosed in single quotes (`'`) or double quotes (`"`), which are equivalent, and may contain any number of characters. If the input stream starting at the current position begins with the string content, this operation succeeds and advances the parser past that string; otherwise, it fails and does not change the current position.
- **Character class**: Character classes are enclosed in square brackets (`[]`), and may contain characters or ranges. If the character at the current position exists in the character class, this operation succeeds and advances the parser by one character (UTF-8) position; otherwise, it fails and does not change the current position.

- **Character**: Can be any character or escape sequence.
- **Range**: Takes the form `c1-c2`, where `c1` and `c2` are characters. It is equivalent to listing all characters whose Unicode code points lie between `c1` and `c2` (inclusive).

- **Escape sequences**: All escape sequences begin with `\`.
  - `\n`: Newline
  - `\r`: Carriage return
  - `\t`: Tab
  - `\[`: `[`, left square bracket
  - `\]`: `]`, right square bracket
  - `\\`: `\`, backslash
  - `\-`: `-`, hyphen
  - `\u{0}` through `\u{1FFFFF}`: Unicode code points

## Remarks

The syntax of PEG itself, described using PEG, looks like the following:

```peg
PEG pe_grammar_for_peg (Grammar)
        Grammar         <- WHITESPACE Header Definition* Final EOF ;
        Header          <- PEG Identifier StartExpr ;
        Definition      <- Attribute? Identifier IS Expression SEMICOLON ;
        Attribute       <- (VOID / LEAF) COLON ;
        Expression      <- Sequence (SLASH Sequence)* ;
        Sequence        <- Prefix+ ;
        Prefix          <- (AND / NOT)? Suffix ;
        Suffix          <- Primary (QUESTION / STAR / PLUS)? ;
        Primary         <- Identifier
                        /  OPEN Expression CLOSE
                        /  Literal
                        /  Class
                        /  DOT ;
        Literal         <- APOSTROPH  (!APOSTROPH  Char)* APOSTROPH  WHITESPACE
                        /  DAPOSTROPH (!DAPOSTROPH Char)* DAPOSTROPH WHITESPACE ;
        Class           <- OPENB (!CLOSEB Range)* CLOSEB WHITESPACE ;
        Range           <- Char TO Char / Char ;
        StartExpr       <- OPEN Expression CLOSE ;
void:   Final           <- "END" WHITESPACE SEMICOLON WHITESPACE ;
        Identifier      <- Ident WHITESPACE ;
leaf:   Ident           <- [_:A-Za-z] [_:A-Za-z0-9]*
                        /  '@' DAPOSTROPH (!DAPOSTROPH .)* DAPOSTROPH ;
        Char            <- CharSpecial / CharUnicode / CharUnescaped ;
leaf:   CharSpecial     <- "\\" [nrt'"\[\]\\] ;
leaf:   CharUnicode     <- "\\" 'u' HexDigit (HexDigit (HexDigit (HexDigit HexDigit?)?)?)?
                        /  "\\" 'u' [0-1] HexDigit HexDigit HexDigit HexDigit HexDigit ;
leaf:   CharUnescaped   <- !"\\" . ;
void:   HexDigit        <- [0-9a-fA-F] ;
void:   TO              <- '-'           ;
void:   OPENB           <- "["           ;
void:   CLOSEB          <- "]"           ;
void:   APOSTROPH       <- "'"           ;
void:   DAPOSTROPH      <- '"'           ;
void:   PEG             <- "PEG" ![_:A-Za-z0-9] WHITESPACE ;
void:   IS              <- "<-"    WHITESPACE ;
leaf:   VOID            <- "void"  WHITESPACE ; # Implies that definition has no semantic value.
leaf:   LEAF            <- "leaf"  WHITESPACE ; # Implies that definition has no terminals.
void:   SEMICOLON       <- ";"     WHITESPACE ;
void:   COLON           <- ":"     WHITESPACE ;
void:   SLASH           <- "/"     WHITESPACE ;
leaf:   AND             <- "&"     WHITESPACE ;
leaf:   NOT             <- "!"     WHITESPACE ;
leaf:   QUESTION        <- "?"     WHITESPACE ;
leaf:   STAR            <- "*"     WHITESPACE ;
leaf:   PLUS            <- "+"     WHITESPACE ;
void:   OPEN            <- "("     WHITESPACE ;
void:   CLOSE           <- ")"     WHITESPACE ;
leaf:   DOT             <- "."     WHITESPACE ;
void:   WHITESPACE      <- (" " / "\t" / EOL / COMMENT)* ;
void:   COMMENT         <- '#' (!EOL .)* EOL ;
void:   EOL             <- "\n\r" / "\n" / "\r" ;
void:   EOF             <- !. ;
END;
```
