//! This module is generated by zpeg.
//! See https://github.com/Anglebase/zpeg.

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArenaAllocator = std.heap.ArenaAllocator;
const List = std.ArrayList;
const Parser = @This();
const Index = usize;

pub const Error = struct {
    pos: Index,
    msg: []const u8,
    stack: []const []const u8 = undefined,
};

ref: []const u8,
pos: Index,
arena: ArenaAllocator,
err_stack: List(Error),
stack: List([]const u8),

/// Create a parser.
///
/// Call the method 'deinit' when it is no longer in use.
/// Caller should ensure that the `source`'s lifetime is longer than this parser.
pub fn init(allocator: Allocator, source: []const u8) !Parser {
    var arena = std.heap.ArenaAllocator.init(allocator);
    const gpa = arena.allocator();
    return .{
        .pos = 0,
        .ref = source,
        .err_stack = try .initCapacity(gpa, 10),
        .stack = try .initCapacity(gpa, 10),
        .arena = arena,
    };
}

fn pushError(self: *Parser, err: Error) !void {
    const allocator = self.arena.allocator();
    var e = err;
    const stack = try allocator.alloc([]const u8, self.stack.items.len);
    @memcpy(stack, self.stack.items);
    e.stack = stack;
    try self.err_stack.append(allocator, e);
}

fn errorPosLessThan(_: *Parser, left: Error, right: Error) bool {
    return left.pos > right.pos;
}

pub fn filterError(self: *Parser) void {
    if (self.err_stack.items.len == 0) return;
    std.mem.sort(Error, self.err_stack.items, self, errorPosLessThan);
    const max_pos = self.err_stack.items[0].pos;
    var end_pos: usize = undefined;
    for (self.err_stack.items, 0..) |*item, i| {
        if (item.pos != max_pos) {
            end_pos = i;
            break;
        }
    }
    self.err_stack.shrinkRetainingCapacity(end_pos);

    const old_len = self.err_stack.items.len;
    var new_len = old_len;
    outer: for (0..old_len) |i| {
        for (self.err_stack.items[i].stack) |str| {
            for (NULLABLE) |nullable| {
                if (std.mem.eql(u8, str, nullable)) {
                    new_len -= 1;
                    continue :outer;
                }
            }
        }
        self.err_stack.items[i - (self.err_stack.items.len - new_len)] = self.err_stack.items[i];
    }
    self.err_stack.shrinkRetainingCapacity(new_len);
}

fn push(self: *Parser, name: []const u8) !void {
    try self.stack.append(self.arena.allocator(), name);
}

fn pop(self: *Parser) void {
    _ = self.stack.pop();
}

fn storeError(self: *Parser) usize {
    return self.err_stack.items.len;
}

fn restoreError(self: *Parser, before: usize) void {
    if (before >= self.err_stack.items.len) return;
    for (before..self.err_stack.items.len) |_| {
        _ = self.err_stack.pop();
    }
}

/// See `init`.
pub fn deinit(self: *Parser) void {
    const gpa = self.arena.allocator();
    self.err_stack.deinit(gpa);
    self.stack.deinit(gpa);
    self.arena.deinit();
}

pub fn reset(self: *Parser) void {
    self.err_stack.clearAndFree(self.arena.allocator());
    self.pos = 0;
}

/// Peek current charactor.
fn peek(self: *Parser) ?u8 {
    if (self.isEOF()) {
        @branchHint(.cold);
        return null;
    }
    return self.ref[self.pos];
}

fn substr(self: *Parser, start: Index, len: Index) ?[]const u8 {
    const end = start + len;
    if (end > self.ref.len) return null;
    return self.ref[start..end];
}

/// Change the current position to the next character.
fn advance(self: *Parser) void {
    self.pos += 1;
}

fn store(self: *Parser) Index {
    return self.pos;
}

fn restore(self: *Parser, pos: Index) void {
    self.pos = pos;
}

fn dot(self: *Parser) !void {
    if (self.pos >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = "Expected any charactor, but found EOF.",
        });
        return error.UnexceptEOF;
    }
    self.advance();
}

/// ""
fn exceptString(self: *Parser, string: []const u8) !void {
    try self.push("exceptString");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    if (self.pos + string.len - 1 >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = try std.fmt.allocPrint(
                self.arena.allocator(),
                "Expected string '{s}', but found EOF.",
                .{string},
            ),
        });
        return error.UnexceptEOF;
    }

    if (std.mem.eql(u8, self.ref[self.pos..(self.pos + string.len)], string)) {
        self.pos += string.len;
        return;
    }
    try self.pushError(.{
        .pos = self.pos,
        .msg = try std.fmt.allocPrint(
            self.arena.allocator(),
            "Expected string '{s}', but found '{s}'.",
            .{ string, self.ref[self.pos..(self.pos + string.len)] },
        ),
    });
    return error.UnexceptChar;
}

fn listCharClass(self: *Parser, charclass: []const u8) ![]const u8 {
    const allocator = self.arena.allocator();
    const chars = try allocator.alloc(u8, charclass.len * 4);

    var pos: usize = 0;
    for (charclass, 0..) |ch, i| {
        if (i == charclass.len - 1) {
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ch;
            pos += 1;
            chars[pos] = '\'';
            pos += 1;
        } else if (i == charclass.len - 2) {
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ch;
            pos += 1;
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = 'o';
            pos += 1;
            chars[pos] = 'r';
            pos += 1;
        } else {
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ch;
            pos += 1;
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ',';
            pos += 1;
        }
    }
    return chars;
}

/// []
fn exceptChar(self: *Parser, charclass: []const u8) !void {
    try self.push("exceptChar");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    if (self.pos >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = try std.fmt.allocPrint(
                self.arena.allocator(),
                "Expected charactor {s}, but found EOF.",
                .{try self.listCharClass(charclass)},
            ),
        });
        return error.UnexceptEOF;
    }

    if (std.mem.containsAtLeast(
        u8,
        charclass,
        1,
        self.ref[self.pos..(self.pos + 1)],
    )) {
        self.advance();
        return;
    }
    try self.pushError(.{
        .pos = self.pos,
        .msg = try std.fmt.allocPrint(
            self.arena.allocator(),
            "Expected charactor {s}, but found '{c}'.",
            .{ try self.listCharClass(charclass), self.ref[self.pos] },
        ),
    });
    return error.UnexceptChar;
}

/// &e
fn @"and"(self: *Parser, item: anytype) !void {
    const start = self.store();
    defer self.restore(start);

    const func = item.@"0";
    const args = item.@"1";

    _ = @call(.auto, func, .{self} ++ args) catch {
        try self.pushError(.{
            .pos = self.pos,
            .msg = "Expected symbol but not.",
        });
        return error.UnexceptToken;
    };
}

/// !e
fn not(self: *Parser, item: anytype) !void {
    const start = self.store();
    defer self.restore(start);

    const func = item.@"0";
    const args = item.@"1";

    _ = @call(.auto, func, .{self} ++ args) catch return;
    try self.pushError(.{
        .pos = self.pos,
        .msg = "Unexpected symbol.",
    });
    return error.UnexceptToken;
}

/// e1 e2 ..
fn sequence(self: *Parser, list: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, list.len);

    inline for (list) |item| {
        const func = item.@"0";
        const args = item.@"1";
        const func_info = @typeInfo(@TypeOf(func)).@"fn";
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => try @call(.auto, func, .{self} ++ args),
            Node => {
                const node: Node = try @call(.auto, func, .{self} ++ args);
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
    }
    return result;
}

/// e1 | e2 | ..
fn choice(self: *Parser, list: anytype) anyerror!List(Node) {
    try self.push("choice");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);
    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, list.len);
    const before = self.storeError();

    inline for (list) |item| {
        const func = item.@"0";
        const args = item.@"1";
        const func_info = @typeInfo(@TypeOf(func)).@"fn";
        blk: switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => {
                @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                self.restoreError(before);
                return result;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                try result.append(allocator, node);
                self.restoreError(before);
                return result;
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
                self.restoreError(before);
                return result;
            },
            else => unreachable,
        }
    }
    return error.NoMatches;
}

/// e*
fn repeat(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    while (true) {
        const before = self.storeError();
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return @errorCast(err);
                }
                break;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
        self.restoreError(before);
    }
    return result;
}

/// e+
fn repeatPlus(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => try @call(.auto, func, .{self} ++ args),
        Node => {
            const node: Node = try @call(.auto, func, .{self} ++ args);
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }

    while (true) {
        const before = self.storeError();
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return @errorCast(err);
                }
                break;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
        self.restoreError(before);
    }
    return result;
}

/// e?
fn optional(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => @call(.auto, func, .{self} ++ args) catch |err| {
            if (err == error.OutOfMemory) {
                return err;
            }
            return result;
        },
        Node => {
            const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return err;
                }
                return result;
            };
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return err;
                }
                return result;
            };
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }
    return result;
}

fn require(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 1);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => try @call(.auto, func, .{self} ++ args),
        Node => {
            const node: Node = try @call(.auto, func, .{self} ++ args);
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }
    return result;
}

pub const NULLABLE = [_][]const u8{
    "WHITESPACE",
    "EOF",
};

pub const Node = union(enum) {
    pub const Leaf = struct {
        start: Index,
        end: Index,
        ref: []const u8,

        pub fn str(self: @This()) []const u8 {
            return self.ref[self.start..self.end];
        }
    };

    pub const Value = struct {
        start: Index,
        end: Index,
        ref: []const u8,

        childs: List(Node),

        pub fn str(self: @This()) []const u8 {
            return self.ref[self.start..self.end];
        }
    };

    pub fn start(self: Node) Index {
        switch (self) {
            .grammar => |n| return n.start,
            .header => |n| return n.start,
            .definition => |n| return n.start,
            .attribute => |n| return n.start,
            .expression => |n| return n.start,
            .sequence => |n| return n.start,
            .prefix => |n| return n.start,
            .suffix => |n| return n.start,
            .primary => |n| return n.start,
            .literal => |n| return n.start,
            .class => |n| return n.start,
            .range => |n| return n.start,
            .startexpr => |n| return n.start,
            .identifier => |n| return n.start,
            .char => |n| return n.start,
            inline else => |n| return n.start,
        }
    }

    pub fn end(self: Node) Index {
        switch (self) {
            .grammar => |n| return n.end,
            .header => |n| return n.end,
            .definition => |n| return n.end,
            .attribute => |n| return n.end,
            .expression => |n| return n.end,
            .sequence => |n| return n.end,
            .prefix => |n| return n.end,
            .suffix => |n| return n.end,
            .primary => |n| return n.end,
            .literal => |n| return n.end,
            .class => |n| return n.end,
            .range => |n| return n.end,
            .startexpr => |n| return n.end,
            .identifier => |n| return n.end,
            .char => |n| return n.end,
            inline else => |n| return n.end,
        }
    }

    pub fn str(self: Node) []const u8 {
        switch (self) {
            .grammar => |n| return n.str(),
            .header => |n| return n.str(),
            .definition => |n| return n.str(),
            .attribute => |n| return n.str(),
            .expression => |n| return n.str(),
            .sequence => |n| return n.str(),
            .prefix => |n| return n.str(),
            .suffix => |n| return n.str(),
            .primary => |n| return n.str(),
            .literal => |n| return n.str(),
            .class => |n| return n.str(),
            .range => |n| return n.str(),
            .startexpr => |n| return n.str(),
            .identifier => |n| return n.str(),
            .char => |n| return n.str(),
            inline else => |n| return n.str(),
        }
    }

    grammar: Value,
    header: Value,
    definition: Value,
    attribute: Value,
    expression: Value,
    sequence: Value,
    prefix: Value,
    suffix: Value,
    primary: Value,
    literal: Value,
    class: Value,
    range: Value,
    startexpr: Value,
    identifier: Value,
    ident: Leaf,
    char: Value,
    charspecial: Leaf,
    charoctalfull: Leaf,
    charoctalpart: Leaf,
    charunicode: Leaf,
    charunescaped: Leaf,
    void: Leaf,
    leaf: Leaf,
    @"and": Leaf,
    not: Leaf,
    question: Leaf,
    star: Leaf,
    plus: Leaf,
    dot: Leaf,
};

fn parseGrammar(self: *Parser) !Node {
    try self.push("Grammar");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.parseWHITESPACE, .{} },
            .{ Parser.parseHeader, .{} },
            .{ Parser.repeat, .{
                .{ Parser.parseDefinition, .{} },
            } },
            .{ Parser.parseFinal, .{} },
            .{ Parser.parseEOF, .{} },
        }} },
    );

    return .{
        .grammar = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseHeader(self: *Parser) !Node {
    try self.push("Header");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.parsePEG, .{} },
            .{ Parser.parseIdentifier, .{} },
            .{ Parser.parseStartExpr, .{} },
        }} },
    );

    return .{
        .header = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseDefinition(self: *Parser) !Node {
    try self.push("Definition");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.optional, .{
                .{ Parser.parseAttribute, .{} },
            } },
            .{ Parser.parseIdentifier, .{} },
            .{ Parser.parseIS, .{} },
            .{ Parser.parseExpression, .{} },
            .{ Parser.parseSEMICOLON, .{} },
        }} },
    );

    return .{
        .definition = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseAttribute(self: *Parser) !Node {
    try self.push("Attribute");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.choice, .{.{
                .{ Parser.parseVOID, .{} },
                .{ Parser.parseLEAF, .{} },
            }} },
            .{ Parser.parseCOLON, .{} },
        }} },
    );

    return .{
        .attribute = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseExpression(self: *Parser) !Node {
    try self.push("Expression");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.parseSequence, .{} },
            .{ Parser.repeat, .{
                .{ Parser.sequence, .{.{
                    .{ Parser.parseSLASH, .{} },
                    .{ Parser.parseSequence, .{} },
                }} },
            } },
        }} },
    );

    return .{
        .expression = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseSequence(self: *Parser) !Node {
    try self.push("Sequence");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.repeatPlus, .{
            .{ Parser.parsePrefix, .{} },
        } },
    );

    return .{
        .sequence = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parsePrefix(self: *Parser) !Node {
    try self.push("Prefix");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.optional, .{
                .{ Parser.choice, .{.{
                    .{ Parser.parseAND, .{} },
                    .{ Parser.parseNOT, .{} },
                }} },
            } },
            .{ Parser.parseSuffix, .{} },
        }} },
    );

    return .{
        .prefix = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseSuffix(self: *Parser) !Node {
    try self.push("Suffix");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.parsePrimary, .{} },
            .{ Parser.optional, .{
                .{ Parser.choice, .{.{
                    .{ Parser.parseQUESTION, .{} },
                    .{ Parser.parseSTAR, .{} },
                    .{ Parser.parsePLUS, .{} },
                }} },
            } },
        }} },
    );

    return .{
        .suffix = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parsePrimary(self: *Parser) !Node {
    try self.push("Primary");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.choice, .{.{
            .{ Parser.parseIdentifier, .{} },
            .{ Parser.sequence, .{.{
                .{ Parser.parseOPEN, .{} },
                .{ Parser.parseExpression, .{} },
                .{ Parser.parseCLOSE, .{} },
            }} },
            .{ Parser.parseLiteral, .{} },
            .{ Parser.parseClass, .{} },
            .{ Parser.parseDOT, .{} },
        }} },
    );

    return .{
        .primary = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseLiteral(self: *Parser) !Node {
    try self.push("Literal");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.choice, .{.{
            .{ Parser.sequence, .{.{
                .{ Parser.parseAPOSTROPH, .{} },
                .{ Parser.repeat, .{
                    .{ Parser.sequence, .{.{
                        .{ Parser.not, .{
                            .{ Parser.parseAPOSTROPH, .{} },
                        } },
                        .{ Parser.parseChar, .{} },
                    }} },
                } },
                .{ Parser.parseAPOSTROPH, .{} },
                .{ Parser.parseWHITESPACE, .{} },
            }} },
            .{ Parser.sequence, .{.{
                .{ Parser.parseDAPOSTROPH, .{} },
                .{ Parser.repeat, .{
                    .{ Parser.sequence, .{.{
                        .{ Parser.not, .{
                            .{ Parser.parseDAPOSTROPH, .{} },
                        } },
                        .{ Parser.parseChar, .{} },
                    }} },
                } },
                .{ Parser.parseDAPOSTROPH, .{} },
                .{ Parser.parseWHITESPACE, .{} },
            }} },
        }} },
    );

    return .{
        .literal = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseClass(self: *Parser) !Node {
    try self.push("Class");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.parseOPENB, .{} },
            .{ Parser.repeat, .{
                .{ Parser.sequence, .{.{
                    .{ Parser.not, .{
                        .{ Parser.parseCLOSEB, .{} },
                    } },
                    .{ Parser.parseRange, .{} },
                }} },
            } },
            .{ Parser.parseCLOSEB, .{} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .class = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseRange(self: *Parser) !Node {
    try self.push("Range");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.choice, .{.{
            .{ Parser.sequence, .{.{
                .{ Parser.parseChar, .{} },
                .{ Parser.parseTO, .{} },
                .{ Parser.parseChar, .{} },
            }} },
            .{ Parser.parseChar, .{} },
        }} },
    );

    return .{
        .range = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseStartExpr(self: *Parser) !Node {
    try self.push("StartExpr");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.parseOPEN, .{} },
            .{ Parser.parseExpression, .{} },
            .{ Parser.parseCLOSE, .{} },
        }} },
    );

    return .{
        .startexpr = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseFinal(self: *Parser) !void {
    try self.push("Final");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"END"} },
            .{ Parser.parseWHITESPACE, .{} },
            .{ Parser.parseSEMICOLON, .{} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseIdentifier(self: *Parser) !Node {
    try self.push("Identifier");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.parseIdent, .{} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .identifier = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseIdent(self: *Parser) !Node {
    try self.push("Ident");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptChar, .{"_:\u{41}\u{42}\u{43}\u{44}\u{45}\u{46}\u{47}\u{48}\u{49}\u{4a}\u{4b}\u{4c}\u{4d}\u{4e}\u{4f}\u{50}\u{51}\u{52}\u{53}\u{54}\u{55}\u{56}\u{57}\u{58}\u{59}\u{5a}\u{61}\u{62}\u{63}\u{64}\u{65}\u{66}\u{67}\u{68}\u{69}\u{6a}\u{6b}\u{6c}\u{6d}\u{6e}\u{6f}\u{70}\u{71}\u{72}\u{73}\u{74}\u{75}\u{76}\u{77}\u{78}\u{79}\u{7a}"} },
            .{ Parser.repeat, .{
                .{ Parser.exceptChar, .{"_:\u{41}\u{42}\u{43}\u{44}\u{45}\u{46}\u{47}\u{48}\u{49}\u{4a}\u{4b}\u{4c}\u{4d}\u{4e}\u{4f}\u{50}\u{51}\u{52}\u{53}\u{54}\u{55}\u{56}\u{57}\u{58}\u{59}\u{5a}\u{61}\u{62}\u{63}\u{64}\u{65}\u{66}\u{67}\u{68}\u{69}\u{6a}\u{6b}\u{6c}\u{6d}\u{6e}\u{6f}\u{70}\u{71}\u{72}\u{73}\u{74}\u{75}\u{76}\u{77}\u{78}\u{79}\u{7a}\u{30}\u{31}\u{32}\u{33}\u{34}\u{35}\u{36}\u{37}\u{38}\u{39}"} },
            } },
        }} },
    );

    return .{
        .ident = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseChar(self: *Parser) !Node {
    try self.push("Char");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.choice, .{.{
            .{ Parser.parseCharSpecial, .{} },
            .{ Parser.parseCharOctalFull, .{} },
            .{ Parser.parseCharOctalPart, .{} },
            .{ Parser.parseCharUnicode, .{} },
            .{ Parser.parseCharUnescaped, .{} },
        }} },
    );

    return .{
        .char = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };
}

fn parseCharSpecial(self: *Parser) !Node {
    try self.push("CharSpecial");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"\\"} },
            .{ Parser.exceptChar, .{"nrt'\"[]\\"} },
        }} },
    );

    return .{
        .charspecial = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseCharOctalFull(self: *Parser) !Node {
    try self.push("CharOctalFull");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"\\"} },
            .{ Parser.exceptChar, .{"\u{30}\u{31}\u{32}"} },
            .{ Parser.exceptChar, .{"\u{30}\u{31}\u{32}\u{33}\u{34}\u{35}\u{36}\u{37}"} },
            .{ Parser.exceptChar, .{"\u{30}\u{31}\u{32}\u{33}\u{34}\u{35}\u{36}\u{37}"} },
        }} },
    );

    return .{
        .charoctalfull = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseCharOctalPart(self: *Parser) !Node {
    try self.push("CharOctalPart");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"\\"} },
            .{ Parser.exceptChar, .{"\u{30}\u{31}\u{32}\u{33}\u{34}\u{35}\u{36}\u{37}"} },
            .{ Parser.optional, .{
                .{ Parser.exceptChar, .{"\u{30}\u{31}\u{32}\u{33}\u{34}\u{35}\u{36}\u{37}"} },
            } },
        }} },
    );

    return .{
        .charoctalpart = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseCharUnicode(self: *Parser) !Node {
    try self.push("CharUnicode");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"\\"} },
            .{ Parser.exceptString, .{"u"} },
            .{ Parser.parseHexDigit, .{} },
            .{ Parser.optional, .{
                .{ Parser.sequence, .{.{
                    .{ Parser.parseHexDigit, .{} },
                    .{ Parser.optional, .{
                        .{ Parser.sequence, .{.{
                            .{ Parser.parseHexDigit, .{} },
                            .{ Parser.optional, .{
                                .{ Parser.parseHexDigit, .{} },
                            } },
                        }} },
                    } },
                }} },
            } },
        }} },
    );

    return .{
        .charunicode = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseCharUnescaped(self: *Parser) !Node {
    try self.push("CharUnescaped");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.not, .{
                .{ Parser.exceptString, .{"\\"} },
            } },
            .{ Parser.dot, .{} },
        }} },
    );

    return .{
        .charunescaped = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseHexDigit(self: *Parser) !void {
    try self.push("HexDigit");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.exceptChar, .{"\u{30}\u{31}\u{32}\u{33}\u{34}\u{35}\u{36}\u{37}\u{38}\u{39}\u{61}\u{62}\u{63}\u{64}\u{65}\u{66}\u{41}\u{42}\u{43}\u{44}\u{45}\u{46}"} },
    );
}

fn parseTO(self: *Parser) !void {
    try self.push("TO");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.exceptString, .{"-"} },
    );
}

fn parseOPENB(self: *Parser) !void {
    try self.push("OPENB");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.exceptString, .{"["} },
    );
}

fn parseCLOSEB(self: *Parser) !void {
    try self.push("CLOSEB");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.exceptString, .{"]"} },
    );
}

fn parseAPOSTROPH(self: *Parser) !void {
    try self.push("APOSTROPH");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.exceptString, .{"'"} },
    );
}

fn parseDAPOSTROPH(self: *Parser) !void {
    try self.push("DAPOSTROPH");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.exceptString, .{"\""} },
    );
}

fn parsePEG(self: *Parser) !void {
    try self.push("PEG");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"PEG"} },
            .{ Parser.not, .{
                .{ Parser.exceptChar, .{"_:\u{41}\u{42}\u{43}\u{44}\u{45}\u{46}\u{47}\u{48}\u{49}\u{4a}\u{4b}\u{4c}\u{4d}\u{4e}\u{4f}\u{50}\u{51}\u{52}\u{53}\u{54}\u{55}\u{56}\u{57}\u{58}\u{59}\u{5a}\u{61}\u{62}\u{63}\u{64}\u{65}\u{66}\u{67}\u{68}\u{69}\u{6a}\u{6b}\u{6c}\u{6d}\u{6e}\u{6f}\u{70}\u{71}\u{72}\u{73}\u{74}\u{75}\u{76}\u{77}\u{78}\u{79}\u{7a}\u{30}\u{31}\u{32}\u{33}\u{34}\u{35}\u{36}\u{37}\u{38}\u{39}"} },
            } },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseIS(self: *Parser) !void {
    try self.push("IS");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"<-"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseVOID(self: *Parser) !Node {
    try self.push("VOID");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"void"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .void = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseLEAF(self: *Parser) !Node {
    try self.push("LEAF");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"leaf"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .leaf = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseSEMICOLON(self: *Parser) !void {
    try self.push("SEMICOLON");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{";"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseCOLON(self: *Parser) !void {
    try self.push("COLON");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{":"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseSLASH(self: *Parser) !void {
    try self.push("SLASH");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"/"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseAND(self: *Parser) !Node {
    try self.push("AND");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"&"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .@"and" = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseNOT(self: *Parser) !Node {
    try self.push("NOT");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"!"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .not = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseQUESTION(self: *Parser) !Node {
    try self.push("QUESTION");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"?"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .question = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseSTAR(self: *Parser) !Node {
    try self.push("STAR");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"*"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .star = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parsePLUS(self: *Parser) !Node {
    try self.push("PLUS");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"+"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .plus = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseOPEN(self: *Parser) !void {
    try self.push("OPEN");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"("} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseCLOSE(self: *Parser) !void {
    try self.push("CLOSE");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{")"} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );
}

fn parseDOT(self: *Parser) !Node {
    try self.push("DOT");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"."} },
            .{ Parser.parseWHITESPACE, .{} },
        }} },
    );

    return .{
        .dot = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };
}

fn parseWHITESPACE(self: *Parser) !void {
    try self.push("WHITESPACE");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.repeat, .{
            .{ Parser.choice, .{.{
                .{ Parser.exceptString, .{" "} },
                .{ Parser.exceptString, .{"\t"} },
                .{ Parser.parseEOL, .{} },
                .{ Parser.parseCOMMENT, .{} },
            }} },
        } },
    );
}

fn parseCOMMENT(self: *Parser) !void {
    try self.push("COMMENT");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.sequence, .{.{
            .{ Parser.exceptString, .{"#"} },
            .{ Parser.repeat, .{
                .{ Parser.sequence, .{.{
                    .{ Parser.not, .{
                        .{ Parser.parseEOL, .{} },
                    } },
                    .{ Parser.dot, .{} },
                }} },
            } },
            .{ Parser.parseEOL, .{} },
        }} },
    );
}

fn parseEOL(self: *Parser) !void {
    try self.push("EOL");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.choice, .{.{
            .{ Parser.exceptString, .{"\n\r"} },
            .{ Parser.exceptString, .{"\n"} },
            .{ Parser.exceptString, .{"\r"} },
        }} },
    );
}

fn parseEOF(self: *Parser) !void {
    try self.push("EOF");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(
        .{ Parser.not, .{
            .{ Parser.dot, .{} },
        } },
    );
}

pub fn parse(self: *Parser) !Node.Value {
    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(
        .{ Parser.parseGrammar, .{} },
    );

    return .{
        .start = start,
        .end = self.pos,
        .ref = self.ref,
        .childs = childs,
    };
}
