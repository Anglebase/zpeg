//! This module is generated by zpeg.
//! See https://github.com/Anglebase/zpeg.

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArenaAllocator = std.heap.ArenaAllocator;
const List = std.ArrayList;
const Parser = @This();
const Index = usize;

pub const Error = struct {
    pos: Index,
    msg: []const u8,
    stack: []const []const u8 = undefined,
};

ref: []const u8,
pos: Index,
arena: ArenaAllocator,
err_stack: List(Error),
stack: List([]const u8),

/// Create a parser.
///
/// Call the method 'deinit' when it is no longer in use.
/// Caller should ensure that the `source`'s lifetime is longer than this parser.
pub fn init(allocator: Allocator, source: []const u8) !Parser {
    var arena = std.heap.ArenaAllocator.init(allocator);
    const gpa = arena.allocator();
    return .{
        .pos = 0,
        .ref = source,
        .err_stack = try .initCapacity(gpa, 10),
        .stack = try .initCapacity(gpa, 10),
        .arena = arena,
    };
}

fn pushError(self: *Parser, err: Error) !void {
    const allocator = self.arena.allocator();
    var e = err;
    const stack = try allocator.alloc([]const u8, self.stack.items.len);
    @memcpy(stack, self.stack.items);
    e.stack = stack;
    try self.err_stack.append(allocator, e);
}

fn errorPosLessThan(_: *Parser, left: Error, right: Error) bool {
    return left.pos > right.pos;
}

/// Filter invalid error messages.
pub fn filterError(self: *Parser) void {
    if (self.err_stack.items.len == 0) return;
    std.mem.sort(Error, self.err_stack.items, self, errorPosLessThan);
    const max_pos = self.err_stack.items[0].pos;
    var end_pos: usize = self.err_stack.items.len;
    for (self.err_stack.items, 0..) |*item, i| {
        if (item.pos != max_pos) {
            end_pos = i;
            break;
        }
    }
    self.err_stack.shrinkRetainingCapacity(end_pos);

    const old_len = self.err_stack.items.len;
    var new_len = old_len;
    outer: for (0..old_len) |i| {
        for (self.err_stack.items[i].stack) |str| {
            for (NULLABLE) |nullable| {
                if (std.mem.eql(u8, str, nullable)) {
                    new_len -= 1;
                    continue :outer;
                }
            }
        }
        self.err_stack.items[i - (self.err_stack.items.len - new_len)] = self.err_stack.items[i];
    }
    self.err_stack.shrinkRetainingCapacity(new_len);
}

fn push(self: *Parser, name: []const u8) !void {
    try self.stack.append(self.arena.allocator(), name);
}

fn pop(self: *Parser) void {
    _ = self.stack.pop();
}

fn storeError(self: *Parser) usize {
    return self.err_stack.items.len;
}

fn restoreError(self: *Parser, before: usize) void {
    if (before >= self.err_stack.items.len) return;
    for (before..self.err_stack.items.len) |_| {
        _ = self.err_stack.pop();
    }
}

/// See `init`.
pub fn deinit(self: *Parser) void {
    const gpa = self.arena.allocator();
    self.err_stack.deinit(gpa);
    self.stack.deinit(gpa);
    self.arena.deinit();
}

pub fn reset(self: *Parser) void {
    self.err_stack.clearAndFree(self.arena.allocator());
    self.pos = 0;
}

fn isEOF(self: *Parser) bool {
    return self.pos >= self.ref.len;
}

/// Peek current charactor.
fn peek(self: *Parser) !?u21 {
    if (self.isEOF()) {
        @branchHint(.cold);
        return null;
    }
    const byte = self.ref[self.pos];
    if (byte & 0b1000_0000 == 0) {
        return std.unicode.utf8Decode(self.ref[self.pos..(self.pos + 1)]) catch return error.NotUTF8;
    } else if (byte & 0b1110_0000 == 0b1100_0000) {
        return std.unicode.utf8Decode(self.ref[self.pos..(self.pos + 2)]) catch return error.NotUTF8;
    } else if (byte & 0b1111_0000 == 0b1110_0000) {
        return std.unicode.utf8Decode(self.ref[self.pos..(self.pos + 3)]) catch return error.NotUTF8;
    } else if (byte & 0b1111_1000 == 0b1111_0000) {
        return std.unicode.utf8Decode(self.ref[self.pos..(self.pos + 4)]) catch return error.NotUTF8;
    } else {
        @branchHint(.cold);
        return error.NotUTF8;
    }
    return @intCast(self.ref[self.pos]);
}

fn substr(self: *Parser, start: Index, len: Index) ?[]const u8 {
    const end = start + len;
    if (end > self.ref.len) return null;
    return self.ref[start..end];
}

/// Change the current position to the next character.
fn advance(self: *Parser) !void {
    const byte = self.ref[self.pos];
    if (byte & 0b1000_0000 == 0) {
        self.pos += 1;
    } else if (byte & 0b1110_0000 == 0b1100_0000) {
        self.pos += 2;
    } else if (byte & 0b1111_0000 == 0b1110_0000) {
        self.pos += 3;
    } else if (byte & 0b1111_1000 == 0b1111_0000) {
        self.pos += 4;
    } else {
        @branchHint(.cold);
        return error.NotUTF8;
    }
}

fn store(self: *Parser) Index {
    return self.pos;
}

fn restore(self: *Parser, pos: Index) void {
    self.pos = pos;
}

fn dot(self: *Parser) !void {
    if (self.pos >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = "Expected any charactor, but found EOF.",
        });
        return error.UnexceptEOF;
    }
    try self.advance();
}

/// ""
fn exceptString(self: *Parser, str: []const u21) !void {
    try self.push("exceptString");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var string = try List(u8).initCapacity(allocator, str.len);
    for (str) |char| {
        var seq: [4]u8 = undefined;
        const len = std.unicode.utf8Encode(char, &seq) catch return error.NotUTF8;
        try string.appendSlice(allocator, seq[0..len]);
    }

    if (self.pos + string.items.len - 1 >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = try std.fmt.allocPrint(
                allocator,
                "Expected string '{s}', but found EOF.",
                .{string.items},
            ),
        });
        return error.UnexceptEOF;
    }

    if (std.mem.eql(u8, self.ref[self.pos..(self.pos + string.items.len)], string.items)) {
        self.pos += string.items.len;
        return;
    }
    try self.pushError(.{
        .pos = self.pos,
        .msg = try std.fmt.allocPrint(
            allocator,
            "Expected string '{s}', but found '{s}'.",
            .{ string.items, self.ref[self.pos..(self.pos + string.items.len)] },
        ),
    });
    return error.UnexceptChar;
}

fn listCharClass(self: *Parser, charclass: []const u21) ![]const u8 {
    const allocator = self.arena.allocator();
    var chars = try List(u8).initCapacity(allocator, 4 * charclass.len);

    for (charclass, 0..) |ch, i| {
        const slice = try allocator.alloc(u8, 4);
        const len = std.unicode.utf8Encode(ch, slice) catch return error.NotUTF8;
        const seq = slice[0..@intCast(len)];

        try chars.append(allocator, '\'');
        try chars.appendSlice(allocator, seq);
        try chars.append(allocator, '\'');

        if (i == charclass.len - 2) {
            try chars.append(allocator, 'o');
            try chars.append(allocator, 'r');
        } else if (i != charclass.len - 1) {
            try chars.append(allocator, ',');
        }
    }
    return chars.toOwnedSlice(allocator);
}

/// []
fn exceptChar(self: *Parser, charclass: []const u21) !void {
    try self.push("exceptChar");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    if (self.pos >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = try std.fmt.allocPrint(
                self.arena.allocator(),
                "Expected charactor {s}, but found EOF.",
                .{try self.listCharClass(charclass)},
            ),
        });
        return error.UnexceptEOF;
    }

    if (std.mem.containsAtLeast(
        u21,
        charclass,
        1,
        &.{(try self.peek()).?},
    )) {
        try self.advance();
        return;
    }
    try self.pushError(.{
        .pos = self.pos,
        .msg = try std.fmt.allocPrint(
            self.arena.allocator(),
            "Expected charactor {s}, but found '{c}'.",
            .{ try self.listCharClass(charclass), self.ref[self.pos] },
        ),
    });
    return error.UnexceptChar;
}

/// &e
fn @"and"(self: *Parser, item: anytype) !void {
    const start = self.store();
    defer self.restore(start);

    const func = item.@"0";
    const args = item.@"1";

    _ = @call(.auto, func, .{self} ++ args) catch {
        try self.pushError(.{
            .pos = self.pos,
            .msg = "Expected symbol but not.",
        });
        return error.UnexceptToken;
    };
}

/// !e
fn not(self: *Parser, item: anytype) !void {
    const start = self.store();
    defer self.restore(start);

    const func = item.@"0";
    const args = item.@"1";

    _ = @call(.auto, func, .{self} ++ args) catch return;
    try self.pushError(.{
        .pos = self.pos,
        .msg = "Unexpected symbol.",
    });
    return error.UnexceptToken;
}

/// e1 e2 ..
fn sequence(self: *Parser, list: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, list.len);

    inline for (list) |item| {
        const func = item.@"0";
        const args = item.@"1";
        const func_info = @typeInfo(@TypeOf(func)).@"fn";
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => try @call(.auto, func, .{self} ++ args),
            Node => {
                const node: Node = try @call(.auto, func, .{self} ++ args);
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
    }
    return result;
}

/// e1 | e2 | ..
fn choice(self: *Parser, list: anytype) anyerror!List(Node) {
    try self.push("choice");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);
    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, list.len);
    const before = self.storeError();

    inline for (list) |item| {
        const func = item.@"0";
        const args = item.@"1";
        const func_info = @typeInfo(@TypeOf(func)).@"fn";
        blk: switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => {
                @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                self.restoreError(before);
                return result;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                try result.append(allocator, node);
                self.restoreError(before);
                return result;
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
                self.restoreError(before);
                return result;
            },
            else => unreachable,
        }
    }
    return error.NoMatches;
}

/// e*
fn repeat(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    while (true) {
        const before = self.storeError();
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return @errorCast(err);
                }
                break;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
        self.restoreError(before);
    }
    return result;
}

/// e+
fn repeatPlus(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => try @call(.auto, func, .{self} ++ args),
        Node => {
            const node: Node = try @call(.auto, func, .{self} ++ args);
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }

    while (true) {
        const before = self.storeError();
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return @errorCast(err);
                }
                break;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
        self.restoreError(before);
    }
    return result;
}

/// e?
fn optional(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => @call(.auto, func, .{self} ++ args) catch |err| {
            if (err == error.OutOfMemory) {
                return err;
            }
            return result;
        },
        Node => {
            const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return err;
                }
                return result;
            };
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return err;
                }
                return result;
            };
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }
    return result;
}

fn require(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 1);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => try @call(.auto, func, .{self} ++ args),
        Node => {
            const node: Node = try @call(.auto, func, .{self} ++ args);
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }
    return result;
}

pub const NULLABLE = [_][]const u8 {
    "EOF",
    "WHITESPACE",
};

pub const Node = union(enum) {
    pub const Leaf = struct {
        start: Index,
        end: Index,
        ref: []const u8,

        pub fn str(self: @This()) []const u8 {
            return self.ref[self.start..self.end];
        }
    };

    pub const Value = struct {
        start: Index,
        end: Index,
        ref: []const u8,

        childs: List(Node),

        pub fn str(self: @This()) []const u8 {
            return self.ref[self.start..self.end];
        }
    };

    pub fn start(self: Node) Index {
        switch(self) {
            .grammar,
            .header,
            .definition,
            .attribute,
            .expression,
            .sequence,
            .prefix,
            .suffix,
            .primary,
            .literal,
            .class,
            .range,
            .startexpr,
            .identifier,
            .char,
            => |n| return n.start,
            inline else => |n| return n.start,
        }
    }

    pub fn end(self: Node) Index {
        switch(self) {
            .grammar,
            .header,
            .definition,
            .attribute,
            .expression,
            .sequence,
            .prefix,
            .suffix,
            .primary,
            .literal,
            .class,
            .range,
            .startexpr,
            .identifier,
            .char,
            => |n| return n.end,
            inline else => |n| return n.end,
        }
    }

    pub fn str(self: Node) []const u8 {
        switch(self) {
            .grammar,
            .header,
            .definition,
            .attribute,
            .expression,
            .sequence,
            .prefix,
            .suffix,
            .primary,
            .literal,
            .class,
            .range,
            .startexpr,
            .identifier,
            .char,
            => |n| return n.str(),
            inline else => |n| return n.str(),
        }
    }

    grammar: Value,
    header: Value,
    definition: Value,
    attribute: Value,
    expression: Value,
    sequence: Value,
    prefix: Value,
    suffix: Value,
    primary: Value,
    literal: Value,
    class: Value,
    range: Value,
    startexpr: Value,
    identifier: Value,
    ident: Leaf,
    char: Value,
    charspecial: Leaf,
    charunicode: Leaf,
    charunescaped: Leaf,
    void: Leaf,
    leaf: Leaf,
    @"and": Leaf,
    not: Leaf,
    question: Leaf,
    star: Leaf,
    plus: Leaf,
    dot: Leaf,
};

fn parseGrammar(self: *Parser) !Node {
    try self.push("Grammar");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.parseWHITESPACE, .{} },.{ Parser.parseHeader, .{} },.{ Parser.repeat, .{.{ Parser.parseDefinition, .{} },}},.{ Parser.parseFinal, .{} },.{ Parser.parseEOF, .{} },}}},);

    return .{
        .grammar = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseHeader(self: *Parser) !Node {
    try self.push("Header");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.parsePEG, .{} },.{ Parser.parseIdentifier, .{} },.{ Parser.parseStartExpr, .{} },}}},);

    return .{
        .header = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseDefinition(self: *Parser) !Node {
    try self.push("Definition");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.optional, .{.{ Parser.parseAttribute, .{} },}},.{ Parser.parseIdentifier, .{} },.{ Parser.parseIS, .{} },.{ Parser.parseExpression, .{} },.{ Parser.parseSEMICOLON, .{} },}}},);

    return .{
        .definition = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseAttribute(self: *Parser) !Node {
    try self.push("Attribute");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.choice, .{.{.{ Parser.parseVOID, .{} },.{ Parser.parseLEAF, .{} },}}},.{ Parser.parseCOLON, .{} },}}},);

    return .{
        .attribute = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseExpression(self: *Parser) !Node {
    try self.push("Expression");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.parseSequence, .{} },.{ Parser.repeat, .{.{ Parser.sequence, .{.{.{ Parser.parseSLASH, .{} },.{ Parser.parseSequence, .{} },}}},}},}}},);

    return .{
        .expression = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseSequence(self: *Parser) !Node {
    try self.push("Sequence");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.repeatPlus, .{.{ Parser.parsePrefix, .{} },}},);

    return .{
        .sequence = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parsePrefix(self: *Parser) !Node {
    try self.push("Prefix");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.optional, .{.{ Parser.choice, .{.{.{ Parser.parseAND, .{} },.{ Parser.parseNOT, .{} },}}},}},.{ Parser.parseSuffix, .{} },}}},);

    return .{
        .prefix = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseSuffix(self: *Parser) !Node {
    try self.push("Suffix");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.parsePrimary, .{} },.{ Parser.optional, .{.{ Parser.choice, .{.{.{ Parser.parseQUESTION, .{} },.{ Parser.parseSTAR, .{} },.{ Parser.parsePLUS, .{} },}}},}},}}},);

    return .{
        .suffix = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parsePrimary(self: *Parser) !Node {
    try self.push("Primary");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.choice, .{.{.{ Parser.parseIdentifier, .{} },.{ Parser.sequence, .{.{.{ Parser.parseOPEN, .{} },.{ Parser.parseExpression, .{} },.{ Parser.parseCLOSE, .{} },}}},.{ Parser.parseLiteral, .{} },.{ Parser.parseClass, .{} },.{ Parser.parseDOT, .{} },}}},);

    return .{
        .primary = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseLiteral(self: *Parser) !Node {
    try self.push("Literal");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.choice, .{.{.{ Parser.sequence, .{.{.{ Parser.parseAPOSTROPH, .{} },.{ Parser.repeat, .{.{ Parser.sequence, .{.{.{ Parser.not, .{.{ Parser.parseAPOSTROPH, .{} },}},.{ Parser.parseChar, .{} },}}},}},.{ Parser.parseAPOSTROPH, .{} },.{ Parser.parseWHITESPACE, .{} },}}},.{ Parser.sequence, .{.{.{ Parser.parseDAPOSTROPH, .{} },.{ Parser.repeat, .{.{ Parser.sequence, .{.{.{ Parser.not, .{.{ Parser.parseDAPOSTROPH, .{} },}},.{ Parser.parseChar, .{} },}}},}},.{ Parser.parseDAPOSTROPH, .{} },.{ Parser.parseWHITESPACE, .{} },}}},}}},);

    return .{
        .literal = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseClass(self: *Parser) !Node {
    try self.push("Class");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.parseOPENB, .{} },.{ Parser.repeat, .{.{ Parser.sequence, .{.{.{ Parser.not, .{.{ Parser.parseCLOSEB, .{} },}},.{ Parser.parseRange, .{} },}}},}},.{ Parser.parseCLOSEB, .{} },.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .class = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseRange(self: *Parser) !Node {
    try self.push("Range");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.choice, .{.{.{ Parser.sequence, .{.{.{ Parser.parseChar, .{} },.{ Parser.parseTO, .{} },.{ Parser.parseChar, .{} },}}},.{ Parser.parseChar, .{} },}}},);

    return .{
        .range = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseStartExpr(self: *Parser) !Node {
    try self.push("StartExpr");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.parseOPEN, .{} },.{ Parser.parseExpression, .{} },.{ Parser.parseCLOSE, .{} },}}},);

    return .{
        .startexpr = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseFinal(self: *Parser) !void {
    try self.push("Final");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{69, 78, 68, }}},.{ Parser.parseWHITESPACE, .{} },.{ Parser.parseSEMICOLON, .{} },.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseIdentifier(self: *Parser) !Node {
    try self.push("Identifier");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.sequence, .{.{.{ Parser.parseIdent, .{} },.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .identifier = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseIdent(self: *Parser) !Node {
    try self.push("Ident");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.choice, .{.{.{ Parser.sequence, .{.{.{ Parser.exceptChar, .{&.{95, 58, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, }}},.{ Parser.repeat, .{.{ Parser.exceptChar, .{&.{95, 58, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, }}},}},}}},.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{64, }}},.{ Parser.parseDAPOSTROPH, .{} },.{ Parser.repeat, .{.{ Parser.sequence, .{.{.{ Parser.not, .{.{ Parser.parseDAPOSTROPH, .{} },}},.{ Parser.dot, .{} },}}},}},.{ Parser.parseDAPOSTROPH, .{} },}}},}}},);

    return .{
        .ident = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseChar(self: *Parser) !Node {
    try self.push("Char");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.choice, .{.{.{ Parser.parseCharSpecial, .{} },.{ Parser.parseCharUnicode, .{} },.{ Parser.parseCharUnescaped, .{} },}}},);

    return .{
        .char = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
            .childs = childs,
        },
    };

}

fn parseCharSpecial(self: *Parser) !Node {
    try self.push("CharSpecial");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{92, }}},.{ Parser.exceptChar, .{&.{110, 114, 116, 39, 34, 91, 93, 45, 92, }}},}}},);

    return .{
        .charspecial = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseCharUnicode(self: *Parser) !Node {
    try self.push("CharUnicode");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.choice, .{.{.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{92, }}},.{ Parser.exceptString, .{&.{117, }}},.{ Parser.exceptString, .{&.{123, }}},.{ Parser.parseHexDigit, .{} },.{ Parser.optional, .{.{ Parser.sequence, .{.{.{ Parser.parseHexDigit, .{} },.{ Parser.optional, .{.{ Parser.sequence, .{.{.{ Parser.parseHexDigit, .{} },.{ Parser.optional, .{.{ Parser.sequence, .{.{.{ Parser.parseHexDigit, .{} },.{ Parser.optional, .{.{ Parser.parseHexDigit, .{} },}},}}},}},}}},}},}}},}},.{ Parser.exceptString, .{&.{125, }}},}}},.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{92, }}},.{ Parser.exceptString, .{&.{117, }}},.{ Parser.exceptString, .{&.{123, }}},.{ Parser.exceptChar, .{&.{48, 49, }}},.{ Parser.parseHexDigit, .{} },.{ Parser.parseHexDigit, .{} },.{ Parser.parseHexDigit, .{} },.{ Parser.parseHexDigit, .{} },.{ Parser.parseHexDigit, .{} },.{ Parser.exceptString, .{&.{125, }}},}}},}}},);

    return .{
        .charunicode = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseCharUnescaped(self: *Parser) !Node {
    try self.push("CharUnescaped");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.not, .{.{ Parser.exceptString, .{&.{92, }}},}},.{ Parser.dot, .{} },}}},);

    return .{
        .charunescaped = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseHexDigit(self: *Parser) !void {
    try self.push("HexDigit");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.exceptChar, .{&.{48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 65, 66, 67, 68, 69, 70, }}},);

}

fn parseTO(self: *Parser) !void {
    try self.push("TO");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.exceptString, .{&.{45, }}},);

}

fn parseOPENB(self: *Parser) !void {
    try self.push("OPENB");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.exceptString, .{&.{91, }}},);

}

fn parseCLOSEB(self: *Parser) !void {
    try self.push("CLOSEB");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.exceptString, .{&.{93, }}},);

}

fn parseAPOSTROPH(self: *Parser) !void {
    try self.push("APOSTROPH");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.exceptString, .{&.{39, }}},);

}

fn parseDAPOSTROPH(self: *Parser) !void {
    try self.push("DAPOSTROPH");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.exceptString, .{&.{34, }}},);

}

fn parsePEG(self: *Parser) !void {
    try self.push("PEG");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{80, 69, 71, }}},.{ Parser.not, .{.{ Parser.exceptChar, .{&.{95, 58, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, }}},}},.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseIS(self: *Parser) !void {
    try self.push("IS");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{60, 45, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseVOID(self: *Parser) !Node {
    try self.push("VOID");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{118, 111, 105, 100, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .void = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseLEAF(self: *Parser) !Node {
    try self.push("LEAF");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{108, 101, 97, 102, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .leaf = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseSEMICOLON(self: *Parser) !void {
    try self.push("SEMICOLON");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{59, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseCOLON(self: *Parser) !void {
    try self.push("COLON");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{58, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseSLASH(self: *Parser) !void {
    try self.push("SLASH");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{47, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseAND(self: *Parser) !Node {
    try self.push("AND");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{38, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .@"and" = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseNOT(self: *Parser) !Node {
    try self.push("NOT");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{33, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .not = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseQUESTION(self: *Parser) !Node {
    try self.push("QUESTION");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{63, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .question = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseSTAR(self: *Parser) !Node {
    try self.push("STAR");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{42, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .star = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parsePLUS(self: *Parser) !Node {
    try self.push("PLUS");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{43, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .plus = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseOPEN(self: *Parser) !void {
    try self.push("OPEN");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{40, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseCLOSE(self: *Parser) !void {
    try self.push("CLOSE");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{41, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

}

fn parseDOT(self: *Parser) !Node {
    try self.push("DOT");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{46, }}},.{ Parser.parseWHITESPACE, .{} },}}},);

    return .{
        .dot = .{
            .start = start,
            .end = self.pos,
            .ref = self.ref,
        },
    };

}

fn parseWHITESPACE(self: *Parser) !void {
    try self.push("WHITESPACE");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.repeat, .{.{ Parser.choice, .{.{.{ Parser.exceptString, .{&.{32, }}},.{ Parser.exceptString, .{&.{9, }}},.{ Parser.parseEOL, .{} },.{ Parser.parseCOMMENT, .{} },}}},}},);

}

fn parseCOMMENT(self: *Parser) !void {
    try self.push("COMMENT");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.sequence, .{.{.{ Parser.exceptString, .{&.{35, }}},.{ Parser.repeat, .{.{ Parser.sequence, .{.{.{ Parser.not, .{.{ Parser.parseEOL, .{} },}},.{ Parser.dot, .{} },}}},}},.{ Parser.parseEOL, .{} },}}},);

}

fn parseEOL(self: *Parser) !void {
    try self.push("EOL");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.choice, .{.{.{ Parser.exceptString, .{&.{10, 13, }}},.{ Parser.exceptString, .{&.{10, }}},.{ Parser.exceptString, .{&.{13, }}},}}},);

}

fn parseEOF(self: *Parser) !void {
    try self.push("EOF");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    _ = try self.require(.{ Parser.not, .{.{ Parser.dot, .{} },}},);

}

pub fn parse(self: *Parser) !Node.Value {
    const start = self.store();
    errdefer self.restore(start);

    const childs = try self.require(.{ Parser.parseGrammar, .{} },);

    return .{
        .start = start,
        .end = self.pos,
        .ref = self.ref,
        .childs = childs,
    };
}