//! This module is generated by zpeg.
//! See https://github.com/Anglebase/zpeg.

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArenaAllocator = std.heap.ArenaAllocator;
const List = std.ArrayList;
const Parser = @This();
const Index = usize;

pub const Error = struct {
    pos: Index,
    msg: []const u8,
    stack: []const []const u8 = undefined,
};

ref: []const u8,
pos: Index,
arena: ArenaAllocator,
err_stack: List(Error),
stack: List([]const u8),

/// Create a parser.
///
/// Call the method 'deinit' when it is no longer in use.
/// Caller should ensure that the `source`'s lifetime is longer than this parser.
pub fn init(allocator: Allocator, source: []const u8) !Parser {
    var arena = std.heap.ArenaAllocator.init(allocator);
    const gpa = arena.allocator();
    return .{
        .arena = arena,
        .pos = 0,
        .ref = source,
        .err_stack = try .initCapacity(gpa, 0),
        .stack = try .initCapacity(gpa, 0),
    };
}

fn pushError(self: *Parser, err: Error) !void {
    const allocator = self.arena.allocator();
    var e = err;
    const stack = try allocator.alloc([]const u8, self.stack.items.len);
    @memcpy(stack, self.stack.items);
    e.stack = stack;
    try self.err_stack.append(allocator, e);
}

fn errorPosLessThan(_: *Parser, left: Error, right: Error) bool {
    return left.pos > right.pos;
}

pub fn filterError(self: *Parser) void {
    if (self.err_stack.items.len == 0) return;
    std.mem.sort(Error, self.err_stack.items, self, errorPosLessThan);
    const max_pos = self.err_stack.items[0].pos;
    var end_pos: usize = undefined;
    for (self.err_stack.items, 0..) |*item, i| {
        if (item.pos != max_pos) {
            end_pos = i;
            break;
        }
    }
    self.err_stack.shrinkRetainingCapacity(end_pos);

    const old_len = self.err_stack.items.len;
    var new_len = old_len;
    outer: for (0..old_len) |i| {
        for (self.err_stack.items[i].stack) |str| {
            for (NULLABLE) |nullable| {
                if (std.mem.eql(u8, str, nullable)) {
                    new_len -= 1;
                    continue :outer;
                }
            }
        }
        self.err_stack.items[i - (self.err_stack.items.len - new_len)] = self.err_stack.items[i];
    }
    self.err_stack.shrinkRetainingCapacity(new_len);
}

fn push(self: *Parser, name: []const u8) !void {
    try self.stack.append(self.arena.allocator(), name);
}

fn pop(self: *Parser) void {
    _ = self.stack.pop();
}

fn storeError(self: *Parser) usize {
    return self.err_stack.items.len;
}

fn restoreError(self: *Parser, before: usize) void {
    if (before >= self.err_stack.items.len) return;
    for (before..self.err_stack.items.len) |_| {
        _ = self.err_stack.pop();
    }
}

/// See `init`.
pub fn deinit(self: *Parser) void {
    const gpa = self.arena.allocator();
    self.err_stack.deinit(gpa);
    self.stack.deinit(gpa);
    self.arena.deinit();
}

pub fn reset(self: *Parser) void {
    self.err_stack.clearAndFree(self.arena.allocator());
    self.pos = 0;
}

/// Peek current charactor.
fn peek(self: *Parser) ?u8 {
    if (self.isEOF()) {
        @branchHint(.cold);
        return null;
    }
    return self.ref[self.pos];
}

fn substr(self: *Parser, start: Index, len: Index) ?[]const u8 {
    const end = start + len;
    if (end > self.ref.len) return null;
    return self.ref[start..end];
}

/// Change the current position to the next character.
fn advance(self: *Parser) void {
    self.pos += 1;
}

fn store(self: *Parser) Index {
    return self.pos;
}

fn restore(self: *Parser, pos: Index) void {
    self.pos = pos;
}

fn dot(self: *Parser) !void {
    if (self.pos >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = "Expected any charactor, but found EOF.",
        });
        return error.UnexceptEOF;
    }
    self.advance();
}

/// ""
fn exceptString(self: *Parser, string: []const u8) !void {
    try self.push("exceptString");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    if (self.pos + string.len - 1 >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = try std.fmt.allocPrint(
                self.arena.allocator(),
                "Expected string '{s}', but found EOF.",
                .{string},
            ),
        });
        return error.UnexceptEOF;
    }

    if (std.mem.eql(u8, self.ref[self.pos..(self.pos + string.len)], string)) {
        self.pos += string.len;
        return;
    }
    try self.pushError(.{
        .pos = self.pos,
        .msg = try std.fmt.allocPrint(
            self.arena.allocator(),
            "Expected string '{s}', but found '{s}'.",
            .{ string, self.ref[self.pos..(self.pos + string.len)] },
        ),
    });
    return error.UnexceptChar;
}

fn listCharClass(self: *Parser, charclass: []const u8) ![]const u8 {
    const allocator = self.arena.allocator();
    const chars = try allocator.alloc(u8, charclass.len * 4);

    var pos: usize = 0;
    for (charclass, 0..) |ch, i| {
        if (i == charclass.len - 1) {
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ch;
            pos += 1;
            chars[pos] = '\'';
            pos += 1;
        } else if (i == charclass.len - 2) {
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ch;
            pos += 1;
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = 'o';
            pos += 1;
            chars[pos] = 'r';
            pos += 1;
        } else {
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ch;
            pos += 1;
            chars[pos] = '\'';
            pos += 1;
            chars[pos] = ',';
            pos += 1;
        }
    }
    return chars;
}

/// []
fn exceptChar(self: *Parser, charclass: []const u8) !void {
    try self.push("exceptChar");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);

    if (self.pos >= self.ref.len) {
        try self.pushError(.{
            .pos = self.pos,
            .msg = try std.fmt.allocPrint(
                self.arena.allocator(),
                "Expected charactor {s}, but found EOF.",
                .{try self.listCharClass(charclass)},
            ),
        });
        return error.UnexceptEOF;
    }

    if (std.mem.containsAtLeast(
        u8,
        charclass,
        1,
        self.ref[self.pos..(self.pos + 1)],
    )) {
        self.advance();
        return;
    }
    try self.pushError(.{
        .pos = self.pos,
        .msg = try std.fmt.allocPrint(
            self.arena.allocator(),
            "Expected charactor {s}, but found '{c}'.",
            .{ try self.listCharClass(charclass), self.ref[self.pos] },
        ),
    });
    return error.UnexceptChar;
}

/// &e
fn @"and"(self: *Parser, item: anytype) !void {
    const start = self.store();
    defer self.restore(start);

    const func = item.@"0";
    const args = item.@"1";

    _ = @call(.auto, func, .{self} ++ args) catch {
        try self.pushError(.{
            .pos = self.pos,
            .msg = "Expected symbol but not.",
        });
        return error.UnexceptToken;
    };
}

/// !e
fn not(self: *Parser, item: anytype) !void {
    const start = self.store();
    defer self.restore(start);

    const func = item.@"0";
    const args = item.@"1";

    _ = @call(.auto, func, .{self} ++ args) catch return;
    try self.pushError(.{
        .pos = self.pos,
        .msg = "Unexpected symbol.",
    });
    return error.UnexceptToken;
}

/// e1 e2 ..
fn sequence(self: *Parser, list: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, list.len);

    inline for (list) |item| {
        const func = item.@"0";
        const args = item.@"1";
        const func_info = @typeInfo(@TypeOf(func)).@"fn";
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => try @call(.auto, func, .{self} ++ args),
            Node => {
                const node: Node = try @call(.auto, func, .{self} ++ args);
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
    }
    return result;
}

/// e1 | e2 | ..
fn choice(self: *Parser, list: anytype) anyerror!List(Node) {
    try self.push("choice");
    defer self.pop();

    const start = self.store();
    errdefer self.restore(start);
    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, list.len);
    const before = self.storeError();

    inline for (list) |item| {
        const func = item.@"0";
        const args = item.@"1";
        const func_info = @typeInfo(@TypeOf(func)).@"fn";
        blk: switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => {
                @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                self.restoreError(before);
                return result;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                try result.append(allocator, node);
                self.restoreError(before);
                return result;
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break :blk;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
                self.restoreError(before);
                return result;
            },
            else => unreachable,
        }
    }
    return error.NoMatches;
}

/// e*
fn repeat(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    while (true) {
        const before = self.storeError();
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return @errorCast(err);
                }
                break;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
        self.restoreError(before);
    }
    return result;
}

/// e+
fn repeatPlus(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => try @call(.auto, func, .{self} ++ args),
        Node => {
            const node: Node = try @call(.auto, func, .{self} ++ args);
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }

    while (true) {
        const before = self.storeError();
        switch (@typeInfo(func_info.return_type.?).error_union.payload) {
            void => @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return @errorCast(err);
                }
                break;
            },
            Node => {
                const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                try result.append(allocator, node);
            },
            List(Node) => {
                var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                    if (err == error.OutOfMemory) {
                        return @errorCast(err);
                    }
                    break;
                };
                defer node_list.deinit(allocator);
                try result.appendSlice(allocator, node_list.items);
            },
            else => unreachable,
        }
        self.restoreError(before);
    }
    return result;
}

/// e?
fn optional(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 5);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => @call(.auto, func, .{self} ++ args) catch |err| {
            if (err == error.OutOfMemory) {
                return err;
            }
            return result;
        },
        Node => {
            const node: Node = @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return err;
                }
                return result;
            };
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = @call(.auto, func, .{self} ++ args) catch |err| {
                if (err == error.OutOfMemory) {
                    return err;
                }
                return result;
            };
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }
    return result;
}

fn require(self: *Parser, item: anytype) anyerror!List(Node) {
    const start = self.store();
    errdefer self.restore(start);

    const allocator = self.arena.allocator();
    var result = try List(Node).initCapacity(allocator, 1);

    const func = item.@"0";
    const args = item.@"1";
    const func_info = @typeInfo(@TypeOf(func)).@"fn";

    switch (@typeInfo(func_info.return_type.?).error_union.payload) {
        void => try @call(.auto, func, .{self} ++ args),
        Node => {
            const node: Node = try @call(.auto, func, .{self} ++ args);
            try result.append(allocator, node);
        },
        List(Node) => {
            var node_list: List(Node) = try @call(.auto, func, .{self} ++ args);
            defer node_list.deinit(allocator);
            try result.appendSlice(allocator, node_list.items);
        },
        else => unreachable,
    }
    return result;
}

